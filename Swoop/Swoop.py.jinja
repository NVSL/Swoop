#-*- Python -*-
""".. module:: Swoop

.. moduleauthor:: Steven Swanson (swanson@cs.ucsd.edu)

Swoop is a library of Python objects for representing and manipulating
Cadsoft Eagle board, schematic, and library files used in designing printed
circuit boards (PCBs).  It parses an input Eagle file, creates a internal
representation data structure that represents the file's contents,
provides accessors and mutators to query, read, and modify those contents, and
generates valid Eagle files as output.

Swoop uses several different objects to represent and manipulate Eagle files.

 1. **EagleFilePart** Swoop use a tree of :class:`EagleFilePart` objects to represent an Eagle file.  There many subclasses of :class:`EagleFilePart` that correspond to different parts of the file.

 2. **Utility classes**  Most notably :class:`From` which provides a fluent interface for Eagle files and :class:`EagleFilePartVisitor` which implements a visitor framework for Swoop data structures.

 3. **Exception classes** For reporting errors.

In addition, Swoop provides :doc:`several mechanisms  </ExtendingSwoop>` for extending its functionality.

Because the Swoop data structures map (almost) directly to Eagle file
structures, some understanding of the Eagle file format is necessary in order
to use Swoop.  However, it is possible to use Swoop without understanding all
the details the format.  The eagle.dtd that ships with Eagle (in the 'doc'
directory) is a good place to start learning about the file format.  If you are
familiar with Eagle, the file format is relatively easy to understand.

The code for most of Swoop is autogenerated by a Python script called
:code:`GenerateSwoop.py` using the Jinja templating system.

Swoop was created by the `NVSL <http://nvsl.ucsd.edu/>`_ at  `UCSD <http://www.ucsd.edu/>`_ as part of the  `Gadgetron project <http://nvsl.ucsd.edu/index.php?path=projects/gadget>`_. 
"""
from __future__ import print_function

from lxml import etree as ET
import io
import logging as log
import copy
import os
import sys
import re
import pickle
import argparse
import inspect
from . import DRU
import collections
import math
from functools import reduce
import pkg_resources

PY2 = sys.version_info < (3,0)


class EagleFormatError(Exception):
    """
    An error occured durig parsing an input file or generating an output file.
    """
    def __init__(self, text=""):
        self.text = text
    def __str__(self):
        return self.text

def NotImplemented(s):
    raise NotImplementedError(s)

def parse_version(v):
    return tuple(map(int, v.split(".")))

class SetNoPickleAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        EagleFile.enablePickle = False
class SetPickleAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        EagleFile.enablePickle = True

def add_args_to_parser(parser):
    parser.add_argument('--swoop:nopickle', nargs=0, action=SetNoPickleAction)
    parser.add_argument('--swoop:pickle', nargs=0, action=SetPickleAction)
    
class SwoopError (Exception):
    """
    An Swoop-related error occurred.
    """
    def __init__(self, text):
        self.text = text
    def __str__(self):
        return self.text


class EagleFilePart(object):

    """

    Base class for all eagle tag objects.  It provides fallback implementations
    of core features, facilities for navagating the part tree, and provides the
    :code:`parent` attribute.
    

    """
    
    def __init__(self):
        self.parent = None

    def get_file(self):
        """
        Get the :class:`EagleFile` containing this object.

        :rtype: :class:`EagleFile`

        """
        r = self.get_root()
        if isinstance(r, EagleFile):
            return r
        else:
            return None

    def get_class_for_tag(self, tag):
        if self.get_file() is None:
            raise NotImplementedError("Creation of children from file-less EFPs is not supported")
        # print "---"
        # print type(self.get_file()).__name__
        # print type(self.get_file()).class_map["library"]
        # print "+++"
        return type(self.get_file()).class_map[tag]
    
    def get_parent(self):
        """
        Get this object's parent.

        :returns: The object's parent.
        :rtype: :class:`EagleFilePart`
        """
        return self.parent

    def detach(self):
        """
        Remove this :class:'EagleFilePart` from its parent.

        :returns: :code:`self`
        :rtype: :class:`EagleFilePart`
        
        """
        self.parent.remove_child(self)
        return self
    
    @classmethod
    def _from_et (cls, et):
        """
        Parse the part from an Element Tree

        """
        raise NotImplementedError("_from_et not implemented in {}".format(cls))
    
    def get_et (self):
        """
        Generate an element tree that represents the :code:`EagleFilePart`.

        :rtype: :class:`etree.ElementTree`

        """
        raise NotImplementedError()

    def get_xml (self, pretty_print=False):
        """
        Return a string that contains the XML representation of this :code:`EagleFilePart`.

        :rtype: :code:`str`

        """
        
        return ET.tostring(self.get_et(),pretty_print=pretty_print)


    def get_root(self):
        """ 
        Find the root of this :class:`EagleFilePart` tree.  This may or may not be an :class:`EagleFile`.

        :rtype: :class:`EagleFilePart`

        """
        if self.get_parent() is not None:
            return self.get_parent().get_root()
        else:
            return self

    def get_DRU(self):
        """
        Return the :class:`DRUFile` object associated with this :code:`EagleFilePart`.
        """
        root = self.get_root()
        if isinstance(root, EagleFile):
            return root.DRUFile
        else:
            return None;
    
    def clone(self):
        """
        Clone the :class:`EagleFilePart`.  It should be identical to the orginial, except that the parent should be :code:`None`.

        :rtype: :class:`EagleFilePart`
        """
        raise NotImplementedError()

    def get_children(self):
        """
        Return a list of all the :code:`EagleFilePart` children of this :code:`EagleFilePart`

        :rtype: List of :class:`EagleFilePart` objects 

        """
        raise NotImplementedError()

    def check_sanity(self, visited_efps = None):
        """
        Perform a (recursive) sanity check on this :code:`EagleFilePart`
        
        :rtype: :code:`None`
        """
        if visited_efps is None:
            visited_efps = {}
        
        for i in self.get_children():
            if i in visited_efps:
                raise SwoopError("Child visited twice. Original parent was {}.  This parent is {}".format(str(visited_efps[i]), str(self)))
            visited_efps[i] = self
            if i.parent != self:
                raise SwoopError("Parent pointer mismatch.  Child = " + str(i) + "; child.parent = " + str(i.parent) + "; Parent = " + str(self) )
            i.check_sanity(visited_efps)

    def with_type(self,t):
        """
        Filter this :code:`EagleFilePart` object based on its type.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if self is an instance of type :code:`t` and :code:`None` otherwise.  This is useful in combination with :class:`From` object.
        
        :param t: The type to check for.
        :returns: :code:`self` if self is an instance of type :code:`t` and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        return self if isinstance(self, t) else None

    def without_type(self,t):
        """
        Filter this :code:`EagleFilePart` object based on its non-membership in a type. 
        
        Return :code:`self` if self is not an instance of type :code:`t` and :code:`None` otherwise.  This is useful in combination with :class:`From` object.
        
        :param t: The type to check for.
        :returns: :code:`self` if self is not an instance of type :code:`t` and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        return self if not isinstance(self, t) else None

    def make_from(self):
        """
        Create a a :class:`From` object containing this object.

        :returns: :class:`From` object containing this object.
        :rtype: :class:`From`

        """
        return From(self)
    
def parseByType(efp, attrType, default, s):

    try:
        if attrType == "None_is_default_string":
            if s is None:
                r = default
            else:
                r = s
        elif attrType == "None_is_default_float":
            if s is None:
                r = default
            else:
                r = float(s)
        elif attrType == "None_is_default_int":
            assert isinstance(default, int)
            if s is None:
                r = default
            else:
                r = int(s)
            assert isinstance(r, int)
        elif attrType == "locked_bool":
            r = (s == "yes")
        elif attrType == "display_bool":
            r = (s != "off")
        elif attrType == "constant_bool":
            r = (s != "no")
        elif s is not None:
            if attrType == "str":
                r = s
            elif attrType == "int":
                r = int(s)
            elif attrType == "float":
                r = float(s)
            elif attrType == "bool":

                if s.upper() in ["YES"]:
                    r = True
                elif s.upper() in ["NO"]:
                    r = False
                else:
                    raise SwoopError("Invalid eagle bool value '" + s +"' in child of " + str(efp))
            elif attrType == "layer_string":
                r = efp.get_file().layer_number_to_name(int(s))
            else:
                raise SwoopError("Unknown attr type '" + attrType + "'")
            assert r is not None
        else:
            r = None
    except ValueError as e:
        raise SwoopError("Bad value: '{}' should be {} ({}) {}".format(s, attrType,e, efp))

    return r

def num_to_str(f): # render integers without the '.0' e.g., 1.0 should be "1"
    if f - math.ceil(f) == 0:
        return str(int(f))
    else:
        return str(f)
    
def unparseByType(efp, attrType, default, v):
    if v is None:
        return v

    if attrType == "None_is_default_string":
        assert default is not None
        if v == default:
            r = None
        else:
            r = v
    elif attrType == "None_is_default_float":
        assert default is not None
        if v == default:
            r = None
        else:
            r = num_to_str(v)
    elif attrType == "None_is_default_int":
        assert default is not None
        assert default != "None"
        assert isinstance(v, int)
        if v == default:
            r = None
        else:
            r = str(v)
    elif attrType == "display_bool":
        if v == True:
            r = None;
        else:
            r = "off"
    elif attrType == "locked_bool":
        if v == False:
            r = None;
        else:
            r = "yes"
    else:
        if attrType == "str":  # Doing nothing to strings lets us handle weird
                               # unicode characters.
            r = v 
        elif attrType in ["int", "float"]:
            r = num_to_str(v)
        elif attrType == "bool":
            if v:
                return "yes"
            else:
                return "no"
        elif attrType == "constant_bool":
            if not v:
                r = "no"
            else:
                r = None
        elif attrType == "layer_string":
            #if efp.get_file() is None:
            #print efp.get_root()
            #   print efp.get_name()
            r = str(efp.get_file().layer_name_to_number(v))
        else:
            raise SwoopError("Unknown attr type '" + attrType + "'")

        if attrType != "constant_bool":
            assert r is not None
    
    return r

def typeCheck(type, v, cannotBeNone):
    if v is None:
        return not cannotBeNone
    
    if type == "None_is_default_string":
        return isinstance(v,str) or v is None
    elif type == "None_is_default_float":
        return isinstance(v,float) or isinstance(v,int) or v is None
    elif type == "None_is_default_int":
        return isinstance(v,int) or v is None
    elif type == "locked_bool":
        return isinstance(v,bool)
    elif type == "str" or type == "layer_string": 
        return isinstance(v, str)
    elif type == "int":
        return isinstance(v,int) 
    elif type == "float":
        return isinstance(v,float) or isinstance(v, int)
    elif type == "bool" or type == "constant_bool":
        return isinstance(v,bool)
    else:
        raise SwoopError("Unknown type '" + type + "'")

class PolygonGeometry:
    def __init__(self):
        pass
    
    def get_bounds_points(self):
        return reduce(lambda a,b: a+b, map(lambda x: x.get_bounds_points(), self.get_vertices()), [])

class OnePointGeometry:
    def __init__(self):
        pass
    
    def get_bounds_points(self):
        """
        Get the location of this :class:`EagleFilePart`.
        
        :returns: :code:`[(x, y)]'
        """
        return [(self.get_x(), self.get_y())]

    def set_location(self,x,y):
        """
        Set the location of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x(x);
        self.set_y(y);
        return self;

    def get_location(self):
        """
        Get the location of this :class:`EagleFilePart`.
        
        :returns: a list: :code:`[x, y]`
        """
        return [self.get_x(),self.get_y()]
    
    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        self.set_x(self.get_x() + dx)
        self.set_y(self.get_y() + dy)
        return self

class DimensionGeometry:
    def __init__(self):
        pass
    def set_size(self,width,height):
        """
        Set the size of this :class:`EagleFilePart`.
        
        :param width: width
        :param height: height
        :returns: :code:`self`
        """
        self.set_dx(width);
        self.set_dy(height);
        return self;

    def get_size(self):
        """
        Get the size of this :class:`EagleFilePart`.
        
        :returns: a list: :code:`[width, height]`
        """
        return [self.get_dx(), self.get_dy()]
    
    def get_width(self):
        """
        Get the width of this :class:`EagleFilePart`.
        
        :returns: the width
        :rtype: :code:`float`
        """
        return self.get_dx()

    def set_width(self,width):
        """
        Set the width of this :class:`EagleFilePart`.
        
        :param width: The width
        :returns: :code:`self`
        """
        self.set_dx(width);
        return self;

    def get_height(self):
        """
        Get the height of this :class:`EagleFilePart`.
        
        :returns: the height
        :rtype: :code:`float`
        """
        return self.get_dy();

    def set_height(self,height):
        """
        Set the height of this :class:`EagleFilePart`.
        
        :param height: The height
        :returns: :code:`self`
        """
        self.set_dy(height);
        return self;


class LineGeometry:
    def __init__(self):
        pass

    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[start_x, start_y, end_x, end_y]`
        """
        return [(self.get_x1(), self.get_y1()),
                (self.get_x2(), self.get_y2())]
                
    def set_start(self,x,y):
        """
        Set the location of the start point of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x1(x);
        self.set_y1(y);
        return self;

    def set_end(self,x,y):
        """
        Set the location of the end point of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x2(x);
        self.set_y2(y);
        return self;

    def get_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[start_x, start_y, end_x, end_y]`
        """
        return [self.get_x1(), self.get_y1(),
                self.get_x2(), self.get_y2()]

    def set_points(self, x1,y1,x2,y2):
        """
        Set the start and end points for this :class:`EagleFilePart`.
        
        :param x1: x coordinate of the start
        :param y1: y coordinate of the start
        :param x2: x coordinate of the end
        :param y2: y coordinate of the end
        :returns: :code:`self`
        """
        self.set_x1(x1);
        self.set_y1(y1);
        self.set_x2(x2);
        self.set_y2(y2);
        return self;

    
    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        self.set_x1(self.get_x1() + dx)
        self.set_y1(self.get_y1() + dy)
        self.set_x2(self.get_x2() + dx)
        self.set_y2(self.get_y2() + dy)
        return self

    def get_length(self):
        return math.sqrt((self.x1-self.x2)**2 + (self.y1-self.y2)**2)
    
class MeasureGeometry(LineGeometry):
    def __init__(self):
        pass
    
    def set_align(self, x,y):
        """
        Set the location of the align point of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x3(x);
        self.set_y3(y);
        return self;

    def get_align(self):
        """
        Get the location of the align point of this :class:`EagleFilePart`.
        
        :returns: a list: :code:`[x, y]`
        """
        return [self.get_x3(), self.get_y3()]

    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        LineGeometry.translate(self,dx,dy)
        self.set_x3(self.get_x3() + dx)
        self.set_y3(self.get_y3() + dy)
        return self

class RectGeometry:
    def __init__(self):
        pass
    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[start_x, start_y, end_x, end_y]`
        """
        return [(self.get_x1(), self.get_y1()),
                (self.get_x2(), self.get_y2())]
                
    def set_lefttop(self,left,top):
        """
        Set the location of the top-left corner of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x1(left);
        self.set_y1(top);
        return self;

    def set_rightbottom(self,right,bottom):
        """
        Set the location of the bottom-right corner of this :class:`EagleFilePart`.
        
        :param x: x coordinate
        :param y: y coordinate
        :returns: :code:`self`
        """
        self.set_x2(right);
        self.set_y2(bottom);
        return self;

    def set_corners(self, left, top, right, bottom):
        """
        Set the start and end points for this :class:`EagleFilePart`.
        
        :param left: left coordinate
        :param top: top coordinate
        :param right: right coordinate
        :param bottom: bottom coordinate
        :returns: :code:`self`
        """
        self.set_x1(left);
        self.set_y1(top);
        self.set_x2(right);
        self.set_y2(bottom);
        return self;

    def get_corners(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.
        
        :returns: :code:`[left, top, right, bottom]`
        """
        return [self.get_x1(), self.get_y1(), self.get_x2(), self.get_y2()]
    
    def translate(self,dx,dy):
        """
        Move this :class:`EagleFilePart`.
        
        :param dx: change in x coordinate
        :param dy: change in y coordinate
        """
        self.set_x1(self.get_x1() + dx)
        self.set_y1(self.get_y1() + dy)
        self.set_x2(self.get_x2() + dx)
        self.set_y2(self.get_y2() + dy)
        return self
    
    def get_height(self):
        return abs(self.get_y1() - self.get_y2())

    def get_width(self):
        return abs(self.get_x1() - self.get_x2())

    def get_area(self):
        return self.get_height() * self.get_width()

class CircleRadiusGeometry:
    def __init__(self):
        pass

    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.

        """
        return [(self.get_x() - self.get_diameter()/2, self.get_y() - self.get_diameter()/2),
                (self.get_x() + self.get_diameter()/2, self.get_y() + self.get_diameter()/2)]
                

    def set_diameter(self,d):
        """
        Set the diameter for this :class:`EagleFilePart`.
        
        :param d: the diameter
        :returns: :code:`self`
        """
        self.set_radius(self,d/2);
        return self
    
    def get_diameter(self):
        """
        Get the diameter for this :class:`EagleFilePart`.
        
        :returns: the diameter
        :rtype: :code:`float`
        """
        return self.get_radius()*2;

class CircleDiameterGeometry:
    def __init__(self):
        pass

    def get_bounds_points(self):
        """
        Get the start and end points for this :class:`EagleFilePart`.

        """
        return [(self.get_x() - self.get_diameter()/2, self.get_y() - self.get_diameter()/2),
                (self.get_x() + self.get_diameter()/2, self.get_y() + self.get_diameter()/2)]
    
    def set_radius(self,r):
        """
        Set the radius for this :class:`EagleFilePart`.
        
        :param r: the radius
        :returns: :code:`self`
        """
        self.set_diameter(self,2*r);
        return self
    
    def get_radius(self):
        """
        Get the radius for this :class:`EagleFilePart`.
        
        :returns: the radius
        :rtype: :code:`float`
        """
        return self.get_diameter()/2;

class RotationGeometry:
    def __init__(self):
        pass

    def _parseRot(self):
        r = self.get_rot();
        if r is None:
            return [False, False, 0]
        
        m = re.match("(M)?(S)?(R)(\d+\.?\d*)", r)
        if m is None:
            raise SwoopError("Illegal rot value: '{}'.".format(r))
        
        v =[m.group(1) is not None,
            m.group(2) is not None,
            float(m.group(4))]
        return v

    def _unparseRot(self, rot):
        self.set_rot("{}{}R{:.1f}".format("M" if rot[0] else "",
                                         "S" if rot[1] else "",
                                         float(rot[2]) % 360.0))
                        
    def set_mirrored(self, m):
        """
        Set the mirrored value of this :class:`EagleFilePart`.
        
        :param m: new mirrored value
        :returns: :code:`self`
        """
        t = self._parseRot();
        t[0] = m;
        self._unparseRot(t);
        return self
    
    def set_spin(self, s):
        """
        Set the spin value of this :class:`EagleFilePart`.
        
        :param m: new spin value
        :returns: :code:`self`
        """
        t = self._parseRot();
        t[1] = s;
        self._unparseRot(t);
        return self

    def set_rotation(self, r):
        """
        Set the rotation value of this :class:`EagleFilePart`.
        
        :param m: new rotation value
        :returns: :code:`self`
        """
        t = self._parseRot();
        t[2] = r;
        self._unparseRot(t);
        return self
        
    def get_mirrored(self):
        """
        Get the mirrored value of this :class:`EagleFilePart`.
        
        :returns: :code:`True` if the :class:`EagleFilePart` object is mirrored, otherwise, :code:`False`
        :rtype: Boolean
        """
        return self._parseRot()[0]
    
    def get_spin(self):
        """
        Get the spin value of this :class:`EagleFilePart`.
        
        :returns: :code:`True` if the :class:`EagleFilePart` object is spin, otherwise, :code:`False`
        :rtype: Boolean
        """
        return self._parseRot()[1]
    
    def get_rotation(self):
        """
        Get the rotation value of this :class:`EagleFilePart`.
        
        :returns: the rotation
        :rtype: :code:`float`
        """
        return self._parseRot()[2]

supportedVersions = { 
            (6,0):"eagle-7.2.0.patched.dtd",
            (6,5,0):"eagle-7.2.0.patched.dtd",
            (6,6,0):"eagle-7.2.0.patched.dtd",
            (7,0,0):"eagle-7.2.0.patched.dtd",
            (7,1,0):"eagle-7.2.0.patched.dtd",
            (7,2,0):"eagle-7.2.0.patched.dtd",
            (7,3,0):"eagle-7.2.0.patched.dtd",
            (7,4,0):"eagle-7.2.0.patched.dtd",
            (7,5,0):"eagle-7.2.0.patched.dtd",
            (7,6,0):"eagle-7.2.0.patched.dtd",
            (7,7,0):"eagle-7.2.0.patched.dtd",
            (8,0,2):"eagle-9.2.2.patched.dtd",
            (8,1,0):"eagle-9.2.2.patched.dtd",
            (8,7,0):"eagle-9.2.2.patched.dtd",
            (8,7,1):"eagle-9.2.2.patched.dtd",
            (9,1,0):"eagle-9.2.2.patched.dtd",
            (9,2,0):"eagle-9.2.2.patched.dtd",
            (9,2,1):"eagle-9.2.2.patched.dtd",
            (9,2,2):"eagle-9.2.2.patched.dtd",
            (9,3,0):"eagle-9.2.2.patched.dtd",
            (9,3,1):"eagle-9.2.2.patched.dtd",
            (9,3,2):"eagle-9.2.2.patched.dtd",
            (9,3,3):"eagle-9.2.2.patched.dtd",
            (9,3,4):"eagle-9.2.2.patched.dtd",
            (9,3,5):"eagle-9.2.2.patched.dtd",
            (9,3,6):"eagle-9.2.2.patched.dtd",
            (9,3,7):"eagle-9.2.2.patched.dtd",
        }
        
    
class EagleFile(EagleFilePart):
    """

    Base class for Eagle files.  It handle opening, parsing, validation, associated errors, writing output, and the mapping between layer numbers and layer names.

    This class also serves a factory class for :class:`EagleFilePart` objects.
    Calling the :meth:`new_*()` methods on an :class:`EagleFile`, yields new
    objects that include any Swoop extensions that have been applied.  

    """

    class_map = {}
    boardFileType = None
    schematicFileType = None
    libraryFileType = None
    isRawSwoop = True
    enablePickle = False # disable this because it shows no performance benefit.

    #{% for tag in tags %}
    def new_{{tag.classname}}(self):
        return type(self).class_map["{{tag.tag}}"]()
    #{% endfor %}        

    def __init__ (self):
        """
        Construct an empty :class:`EagleFile`.
        """
        EagleFilePart.__init__(self)
        self.filename= None
        self.root = None
        #self.tree = None
        self.layers = {}
        self.layersByName = {}
        self.version = None
        
    def get_filename(self):
        return self.filename
    def set_filename(self, name):
        self.filename = name
        return self

    @classmethod
    def get_DTD(cls, root):
        version = parse_version(root.get('version'))
        filename = supportedVersions[version]
        log.info("Using DTD: {}".format(filename))
        with pkg_resources.resource_stream(__name__, filename) as dtd:
            return ET.DTD(dtd)
    
    @classmethod
    def get_schematic_file_type(cls):
        if cls.schematicFileType is None:
            return SchematicFile
        else:
            return cls.schematicFileType

    @classmethod
    def get_board_file_type(cls):
        if cls.boardFileType is None:
            return BoardFile
        else:
            return cls.boardFileType
        
    @classmethod
    def get_library_file_type(cls):
        if cls.libraryFileType is None:
            return LibraryFile
        else:
            return cls.libraryFileType
        
    def validate(self):
        """
        Check that this file conforms to the eagle DTD. Return True, if it does, False otherwise.

        :rtype: Bool
        """
        et = self.get_et()
        dtd = EagleFile.get_DTD(et)
        if dtd is not None:
            v = dtd.validate(et)
        else:
            log.warning("Can't validate Swoop tree.  DTD is missing.")
            v = True;
        
        if not v:
            log.error("Eagle file opened as '" + str(self.filename) +"' is invalid: " + str(dtd.error_log.filter_from_errors()[0]))
        else:
            log.info("Eagle file opened as '" + str(self.filename) +"' parsed to valid Eagle data.")

        for t in et.findall(".//*"):
            for a in list(t.attrib.values()):
                if a == str(None):
                    log.warning("Eagle file opened as '" + str(self.filename) +"' has 'None' attribute value")
                    return False
        
        return (v, dtd)

    @classmethod
    def open(cls,filename, bestEffort = True, DRUFile=None):
        """
        Loads a Eagle file from a .sch, .lbr, or .brd file.  A synonym for :meth:`EagleFile.from_file`
        
        :param filename: Filename to load.
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :param DRUFile: A DRU file to use.  You don't need to worry about this unless you need precisely correct answers to questions about the geometry of things on your board.  By default, it uses sensible defaults.
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        return cls.from_file(filename, bestEffort, DRUFile)

    @classmethod
    def from_etree(cls, et):
        """
        Build file from element tree.

        :param et: Element tree data structure (e.g., returned by :code:`ElementTree.parse(filename)`)
        """
        dtd = EagleFile.get_DTD(et.getroot())
        if dtd:
            if not dtd.validate(et.getroot()):
                raise SwoopError("Tried to load from invalid eTree")
        if issubclass(cls, LibraryFile):
            raise NotImplementedError("Can't create library from raw etree.  What's the librarie's name?")
        return cls._from_et(et.getroot(), None)

    @classmethod
    def from_stream (cls, fileClass, stream, bestEffort = True, DRUFile=None, pickle=True, filename=None):
        """
        Load an Eagle file from a stream.   You need to pass the the class you would like it parsed as.

        :param fileClass: We will return an instance of this class.  Necessary because we may not have a filename.  Good choices are :class:`SchematicFile`, :class:`LibraryFile`, or :class:`BoardFile`.
        :param stream: stream to load. 
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        try:
            root = ET.fromstring(stream.read())
        except ET.XMLSyntaxError as e:
            raise EagleFormatError("Eagle file '" + str(filename) +"' doesn't look like XML eagle file.  Try resaving with a newer version of eagle.")
        
        dtd = EagleFile.get_DTD(root)
        v = dtd.validate(root)
        if not v:
            if bestEffort:
                log.warning("Eagle file opened as '" + str(filename) +"' is invalid on disk: " + str(dtd.error_log.filter_from_errors()[0]))
            else:
                raise EagleFormatError("Eagle file opened as '" + str(filename) +"' is invalid on disk: " + str(dtd.error_log.filter_from_errors()[0]))


        if issubclass(fileClass, LibraryFile):
            ef = fileClass._from_et(root, None, filename)
        else:
            ef = fileClass._from_et(root, None)
            
        ef.filename = filename

        if parse_version(ef.get_version()) not in supportedVersions:
            if bestEffort:
                log.warning("Eagle file opened as '" + str(filename) +"' is not one of " + str(supportedVersions) + ".  Doing our best.")
            else:
                raise EagleFormatError("Eagle file opened as '" + str(filename) +"' is not one of " + str(supportedVersions) + ".  Chickening out.")

        if DRUFile is None:
            DRUFile = "default.dru"
            
        with pkg_resources.resource_stream(__name__, DRUFile) as s:

            ef.DRUFile = DRU.DRUFile(s)
            
        ef.check_sanity()
        if cls.isRawSwoop and EagleFile.enablePickle:
            pickle.dump(ef, open(filename + ".pickle", "w"), pickle.HIGHEST_PROTOCOL)

        return ef

    
    @classmethod
    def from_file (cls, filename, bestEffort = True, DRUFile=None, pickle=True):
        """
        Loads a Eagle file from a .sch, .lbr, or .brd file.  A synonym for :meth:`EagleFile.open`

        :param filename: Filename to load. 
        :param bestEffort: If :code:`True`, load the file even if it doesn't conform to the DTD.        
        :returns: A new :class:`BoardFile`, :class:`LibraryFile`, or :class:`SchematicFile` object
        """
        usePickle = False;
        if cls.isRawSwoop:
            realStat = os.stat(filename)
            try:
                pickleStat = os.stat(filename + ".pickle")
                if pickleStat.st_mtime > realStat.st_mtime:
                    usePickle = True
            except Exception as e:
                pass;#print e


            if usePickle and EagleFile.enablePickle:
                ef = pickle.load(open(filename + ".pickle"))
                return ef

        f = open(filename, "rb");
        
        if filename[-4:] == ".sch":
            n = cls.from_stream(cls.get_schematic_file_type(), f, bestEffort, DRUFile, pickle)
        elif filename[-4:] == ".brd":
            n = cls.from_stream(cls.get_board_file_type(), f, bestEffort, DRUFile, pickle)
        elif filename[-4:] == ".lbr":
            n = cls.from_stream(cls.get_library_file_type(), f, bestEffort, DRUFile, pickle, filename=filename)
        else:
            raise SwoopError("Unknown file suffix: '" + filename[-4:] + "'")

        n.set_filename(filename)
        return n

    @staticmethod
    def from_file_by_type(filename, ftype):
        n = EagleFile.from_file(filename)
        if not isinstance(n, ftype):
            raise SwoopError("File is '" + filename + "' is not " + ftype.__name__)
        return n

    def write (self, file, check_sanity=True, dtd_validate=True):
        """
        Exports the Schematic to an EAGLE schematic file.
        
        :param file: Filename or file-like object for output.
        :param check_sanity:  Perform semantic sanity checks before output.
        :param dtd_validate:  Check for DTD compliance before output.
        """

        header="""<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE eagle SYSTEM "eagle.dtd">
""".encode("utf8")
        if check_sanity:
            self.check_sanity()
        et = self.get_et()
        if dtd_validate:
            (v, dtd) =  self.validate()
        else:
            v = True
            dtd = None
   
        if not v:
            if self.filename is not None:
                f = open(self.filename + ".broken.xml", "w")
                to_write = header + ET.tostring(ET.ElementTree(et),pretty_print=True)
                f.write(to_write.decode("utf8"))

            if len(dtd.error_log.filter_from_errors()) > 0:
                raise SwoopError("Swoop structure does not validate" + str(dtd.error_log.filter_from_errors()[0]))
            else:
                raise SwoopError("Swoop structure is not valid.")
        else:
            if hasattr(file, 'read') and hasattr(file, 'write'):
                f = file
                filename = None
            else:
                f = open(file, "w")
                filename = file
            to_write = header+ET.tostring(ET.ElementTree(et),pretty_print=True)
            f.write(to_write.decode("utf8"))

    def add_layer (self, layer):
        """
        Add a layer to this file.
        
        :param layer: The :class:`Layer` to add.

        :rtype: :code:`None`

        """

        assert isinstance(layer, Layer)

        self.layers[int(layer.get_number())] = layer
        self.layersByName[layer.get_name()] = layer
        layer.parent = self

    def get_layer(self, v):
        """
        Lookup a layer by number or name.
        
        :param v: A :code:`str`, or :code:`int` describing a layer.
        :returns: The layer.
        :rtype:  :class:`Layer`
        """
        if isinstance(v, int):
            try:
                return self.layers[v]
            except:
                raise SwoopError("Unknown layer number: {}".format(v))
        elif isinstance(v, str):
            try:
                return self.layersByName[v]
            except:
                raise SwoopError("Unknown layer name: '{}'".format(v))
        else:
            raise SwoopError("Wrong type for layer lookup: {}".format(type(v)))
    
    def get_layers(self):
        """
        Get a list of layers.
        
        :rtype: List of :code:`Swoop.Layer` objects for this eagle file.

        """
        return list(self.layers.values())

    def get_layersByNumber(self):
        """
        Get a map of numbers to Layer objects.

        :rtype: Map of :code:`EagleFilePart` objects keyed by layer number.
        """
        return self.layers

    def get_layersByName(self):
        """
        Get a map of names to Layer objects.

        :rtype: Map of :code:`EagleFilePart` objects keyed by layer number.
        """
        return self.layersByName

    def get_mirrored_layer(self, l):
        """

        Find the mirrored version of a layer.  For 'mirrored' objects, Eagle will
        automatically change layers from a 'top' layer to a 'bottom' layer under the following conditions:

        * The 'top' layer starts with 't' and has an odd layer number.
        * The 'bottom' layer startes with 'b' and has the layer number one higher than the corresponding 'top' layer.
        * The 'top' layer's numbers is less than or equal to 59.

        For instance tPlace (number 21) because bPlace (number 22).

        This function returns the mirrored version of a layer according to the rules above.

        :param l: A :code:`str`, :code:`int`, or :class:`Layer` specifying a layer.
        :returns: A description of the mirrored layer.
        :rtype:  Same type as :code:`l`
        """

        if (isinstance(l, str)):
            return self.get_mirrored_layer(self.layersByName[l]).get_name()
        elif (isinstance(l, int)):
            return self.get_mirrored_layer(self.layers[l]).get_number()
        elif (isinstance(l, Layer)):
            if l.get_number() <= 60: # According to
                                   # http://www.element14.com/community/thread/42249/l/creating-new-pairs-of-topbottom-layers,
                                   # the 't' and 'b' prefixes only work up to
                                   # layer 60
                name = l.get_name()
                if name[0] == "t":
                    assert (l.get_number() % 2) == 1 # 't' layers are supposed to be odd-numbered
                    name = "b" + name[1:]
                elif name[0] == "b":
                    assert (l.get_number() % 2) == 0 # 'b' layers are supposed to be even-numbered
                    name = "t" + name[1:]
                elif name == "Top":
                    name = "Bottom"
                elif name == "Bottom":
                    name = "Top"
                    
                if name not in self.layersByName:
                    raise SwoopError("Tried to mirror layer {}, but '{}' doesn't exist".format(l,name))
                else:
                    return self.layersByName[name]
            return l

    def parse_layer_number(self, num):

        if num is None:
            return None
        return self.layer_number_to_name(num)

    def unparse_layer_name(self, name):
        if name is None:
            return None
        return self.layer_name_to_number(name)
    
    def layer_number_to_name(self, num):

        """
        Given a layer number, return the name.

        :rtype: :class:`Layer` 
        """
        n = int(num)
        if n not in self.layers:
            raise SwoopError("No such layer number: {}".format(num))
        #return "Layer" + str(num)
        else:
            return self.layers[n].name

    def layer_name_to_number(self, name):
        """
        Given a layer name, return the number.

        :rtype: :class:`Layer` 
        """
        assert type(name) is str
        if name not in self.layersByName:
            raise SwoopError("No layer named '" + name + "' in " + str(self.filename))
        return self.layersByName[name].number

    def remove_layer(self, layer):
        """
        Remove a layer.
        
        :param layer: :class:`Layer` object, layer name, or layer number that should be deleted.
        
        :rtype: :code:`None`
        """
        if type(layer) is str:
            l = self.layersByName[layer]
            self.remove_layer(l)
        elif type(layer) is int:
            l = self.layers[layer]
            self.remove_layer(l)
        elif isinstance(layer, Layer):
            self.layersByName[layer.name].parent = None
            del self.layersByName[layer.name]
            del self.layers[int(layer.number)]
        else:
            raise SwoopError("Invalid layer spec: " + str(layer))
            
    # def get_manifest(self):
    #     raise NotImplementedError("Manifest for " + str(type(self)))

    def find_library_by_name(self, l):
        """
        Lookup a library by name and return it.

        :param l: Library name.
        :rtype: :class:`Library` or :code:`None` if the library is not present.
        """
        return self.libraries.get(l)

class nothing():
    def __init__(self):
        pass

def Mixin(mixin, prefix, base=EagleFile):
    """Extend Swoop by adding a mixin to every class.

    This function creates a new subclasses of every class Swoop uses to
    represent an Eagle file (including the file types).  The names of the new
    classes are prefixed with :code:`prefix` and they all inherit from the
    original class and :code:`mixin`.

    :param mixin: Mixin class or module.  Its constructor for a mixin class (Or the classes in a mixin module) should take no arguments.
    :param prefix: Prefix for the class name.  It'll be prepended to the names of all the Swoop classes.
    :param base: Starting point for the extension.  This should either be :class:`Swoop.EagleFile` or a class returned by a previous call to this function.
    :returns: A new subclass of :code:`base` that can be used just like :class:`EagleFile`
    :rtype: A class.

    """
    def Extend(C, m, name):
        class T(C,m):
            class_map={}
            def __init__(self):
                C.__init__(self)
                m.__init__(self)
        T.__name__ = name
        return T

    def get_class_from_module(module, theClass):
        #print module
        #print theClass
        c = inspect.getmembers(module, inspect.isclass)
        #print c
        for i in c:
            if i[1].__name__.split(".")[-1] == theClass.__name__.split(".")[-1]:
                log.debug("Found class '{}' for '{}'".format(i[1], theClass))
                return i[1]
            else:
                log.debug("Class '{}' was no match for '{}'".format(i[1], theClass))
                
        return None
        
    base_mixin = get_class_from_module(mixin,EagleFile)
    base_mixin = base_mixin if base_mixin is not None else nothing

    n = Extend(base, base_mixin, prefix + base.__name__)
    n.isRawSwoop = False
    for i in base.class_map:
        if inspect.isclass(mixin):
            n.class_map[i] = Extend(base.class_map[i], mixin, prefix + base.class_map[i].__name__)
        elif inspect.ismodule(mixin):
            c = get_class_from_module(mixin, EagleFile.class_map[i])
            if c is not None:
                log.info("Patching {} with {}".format(base.class_map[i], c))
                ext =  Extend(base.class_map[i], c, prefix + base.class_map[i].__name__)
                n.class_map[i] = ext
            else:
                n.class_map[i] = base.class_map[i]
        
    board_mixin = get_class_from_module(mixin,BoardFile)
    board_mixin = board_mixin if board_mixin is not None else nothing
        
    schematic_mixin = get_class_from_module(mixin,SchematicFile)
    schematic_mixin = schematic_mixin if schematic_mixin is not None else nothing
        
    library_mixin = get_class_from_module(mixin,LibraryFile)
    library_mixin = library_mixin if library_mixin is not None else nothing
        

    n.boardFileType = Extend(base.get_board_file_type(),
                             board_mixin, prefix + base.get_board_file_type().__name__)
    
    n.schematicFileType = Extend(base.get_schematic_file_type(),
                                 schematic_mixin, prefix + base.get_schematic_file_type().__name__)
    
    n.libraryFileType = Extend(base.get_library_file_type(),
                               library_mixin, prefix + base.get_library_file_type().__name__)

    n.boardFileType.class_map = copy.copy(n.class_map)
    n.schematicFileType.class_map = copy.copy(n.class_map)
    n.libraryFileType.class_map = copy.copy(n.class_map)

    #print("there " + str(n))
    #print("there " + str(n.boardFileType))
    #print("there " + str(n.schematicFileType))
    #print("there " + str(n.libraryFileType))
    #print("there " + str(n.libraryFileType.class_map))
    #print("here" + str(n.class_map.get("library")))
    return n

    
def smartAddSubTags(root, path):

    """
    Add tags as need to create a container for the contents of an xpath.

    :rtype: :code:`None`
    """
    pathSegments = path.split("|")[0].replace("./","").split("/")
    target = root
    for p in pathSegments[0:-1]:
        new_target = target.find(p)
        if new_target is None:
            target = ET.SubElement(target,p)
        else:
            target = new_target
    return target

def filter_list(l, match_type, attrs):
    r = []
    if attrs is None:
        attrs = {}
        
    for efp in l:
        match = True
        for k in attrs:
            if type(attrs[k]) in [str,int,float]:
                match = match and getattr(efp,k) == attrs[k]
            elif callable(attrs[k]):
                match = match and attrs[k](efp)
            else:
                assert False
        if match_type is not None:
            match = match and isinstance(efp, match_type)
        if match:
            r.append(efp)
    return r

def matching(e):
    """Helper function for filtering :class:`From` objects.  The filter allows
    items to pass based on whether they match the regex :code:`e`.  For
    example, this will print the number of packages with names starting with
    "FOO" in a library.

    .. code-block:: python
    
    print(From(library).
          get_packages().
          with_name(matching("^FOO.*")).count()

    """
    return lambda x: re.match(e, x) is not None

def not_matching(e):
    """Helper function for filtering :class:`From` objects.  The filter allows
    items to pass based on whether they *don't* match the regex :code:`e`.  
    
    For example, this will print the number of packages with names not starting
    with "FOO" in a library.

    .. code-block:: python
    
    print(From(library).
          get_packages().
          with_name(not_matching("^FOO.*")).count()

    """
    return lambda x: re.match(e, x) is None


class From(object):
    """An ordered collection of (usually) :class:`EagleFilePart` objects.  Invoke
    a method on a :class:`From` object, invokes the same method with the same
    arguments on all the objects it holds.  The results are placed in a new
    :class:`From` object that is returned.

    :class:`From` objects also provide several utility functions for
    accessing, filtering, mapping, and reducing their contents.

    You can combine the contents of the two :class:`From` objects with the
    :code`+` operator.
    
    :class:`From` objects are iterable.

    """
    def __init__(self, *args):
        r = []
        for i in args:
            if type(i) is list:
                r += i
            elif type(i) == From:
                r += i.efps
            else:
                r += [i]
        self.efps = r

    def __str__(self):
        return "From: " + str(self.efps)

    def __repr__(self):
        return self.__str__()

    def __len__(self):
        return len(self.efps)

    def __getitem__(self,n):
        return self.efps[n]

    def __add__(self, rhs):
        return self.append(rhs)
    
    def __getattr__(self, name):
        def wrapper(*args, **kargs):
            r = []
            for i in self.efps:
                t = getattr(i,name)(*args,**kargs)
                if type(t) is dict:
                    r += list(t.values())
                elif type(t) is list:
                    r += t
                elif t is None:
                    pass
                else:
                    r.append(t)
            return From(r)
        return wrapper

    def append(self, l):
        """
        Merge the contents of :code:`l` into this :class`From` object.

        :param l: Python list of :class:`EagleFilePart` objects, a :class:`From` object, or an :class:`EagleFilePart` object.
        :returns: This :class:`From` object with the new items added.
        :rtype: :class:`From` 
        """
        if type(l) is list:
            self.efps += l
        elif type(l) == From:
            self.efps += l.efps
        else:
            self.efps += [l]
        return self

    def unpack(self):
        """
        Return the contents of the :class:`From` object as a list.
        
        :returns: A list containing the contents of the :class:`From`
        :rtype:  List
        """
        return self.efps

    def first(self):
        """
        Return the first item in the :class:`From` object.  If the :class:`From` is empty, raise an :class:`IndexError` exception.
        
        :returns: The first item in the :class:`From`
        :rtype:  Varies
        :throws: :class:`IndexError`
        """
        try:
            return self.efps[0]
        except:
            return None

    def filtered_by(self, func):
        """
        Filter the :class:`From`.  Similar to the builtin :code:`filter` method.
        
        :returns: A :class:`From` object contain the elements, :code:`x` for which :code:`func(x)` return :code:`True`
        """
        return From([x for x in self.efps if func(x)])

    def unique(self):
        """
        Remove duplicate elements from the :class:`From`
        
        :returns: A :class:`From` object contain the unique elements in this :class:`From`.
        """
        return From(list(set(self.efps)))

    def count(self):
        """
        Count the elements in the :class:`From`

        :returns: The number of elements.
        :rtype: int
        """
        return len(self.efps)

    def sort(self, cmp=None, key=None, reverse=False):
        """
        Sort the :class:`From` object.  Similar to the builtin :code:`sorted` method (and takes the same arguments).

        :param cmp: Comparison function.
        :param key: A key accessor function.
        :param reverse: If :code:`True` sort in reverse order.
        
        :returns: A sorted :class:`From`
        """
        return From(sorted(self.efps, cmp, key, reverse))

    def map(self, func):
        """
        Apply a function to the elments of this :class:`From` and return a :class:`From` containing the results.  Similar to the builtin :code:`map` function.
        
        :param func: The function to apply.
        :returns: A :class:`From` containing the results.
        """
        return From(list(map(func, self.efps)))

    def apply(self, func):
        """Apply a function to the elments of this :class:`From` and return a
        :class:`From` containing the results.  Similar to the builtin
        :code:`map` function.  A synonym for :meth:`From.map`.
        
        :param func: The function to apply.
        :returns: A :class:`From` containing the results.

        """
        return From(list(map(func, self.efps)))

    
    def reduce(self, func, init=None):
        """
        Reduce the elments of this :class:`From` and return the result.  Similar to the builtin :code:`reduce` function.
        
        :param func: The function to apply.
        :param init: The starting value for the reduction.
        :returns: The reduce result
        :rtype: Varies
        """
        if init is None:
            return reduce(func, self.efps)
        else:
            return reduce(func, self.efps, init)

#def from_file(filename):
#    return From(EagleFile.from_file(filename))


class EagleFilePartVisitor(object):
    """A visitor utility class for :class:`EagleFile` objects.  

    The class traverses a subtree of :class:`EagleFilePart` objects in
    depth-first order.  Subclasses can define *vistor* methods of the form
    :code:`*X*_pre()` and :code:`*X*_post()` that will be called in pre-order
    and post-order during the traversal.  If a subclass doesn't define a
    particular an :class:`EagleFilePart` subclass, :meth:`default_pre` and
    :meth:`default_pre` will be used instead.

    Subclasses can also override :meth:`visitFilter` and
    :meth:`decendFilter` to control which :class:`EagleFilePart` the visitor
    invokes the visitor methods on and which :class:`EagleFilePart` the visitor
    decends into.  By default, both visitor methods are called on all
    :class:`EagleFilePart` objects and in the visitor always decends.

    The :meth:`go` method start execution.  It also returns :code:`self` so
    you can easily apply accessor functions after execution.  You can also call
    :meth:`visit` on an :class:`EagleFilePart` object to visit the subtree
    underneath it

    For example, here's a simple visitor that counts the total number of
    :class:`EagleFileParts` in a file and, separately, the number of
    :class:`Element` objects:
    
    .. code-block:: python

        class Counter(SwoopTools.EagleFilePartVisitor):
            def __init__(self, root=None):
                SwoopTools.EagleFilePartVisitor.__init__(self,root)
                self.count = 0;
                self.elementCount = 0
                self.layerCount = 0
            def default_pre(self, efp):
                self.count += 1
            def Element_pre(self, e):
                self.count += 1
                self.elementCount += 1
    
    And you can use it like so:

    .. code-block:: python

        from Swoop import *
        from SwoopTools import *
        ef = EagleFile.from_file(my_file)
        c = Counter(ef)
        print "The file has this many parts: " + str(c.go().count)
        print "There are this many Elements: " + str(c.elementCount)

    """

    def __init__(self, root=None):
        self.root = root

    def go(self):
        """
        Start the visiting process.
        
        :rtype: :code:`self`
        """
        self.visit(self.root)
        return self
    
    def visitFilter(self, e):
        """Predicate that determines whether to call the visit functions on this
        :class:`EagleFilePart`.  The default implementation returns ``True``.
        
        :param e: The :class:`EagleFilePart` to be visited.
        :rtype:   ``Bool``

        """
        return True

    def decendFilter(self, e):
        """Predicate that determines whether to decend into the subtree rooted at ``e``.  The default implementation returns ``True``.
        
        :param e: The root :class:`EagleFilePart`.
        :rtype:   ``Bool``

        """
        return True


    def default_pre(self,e):
        """Default pre-order visitor function.

        This method can return a value that will be passed to the corresponding
        post-order visitor function, making it easy to pass state between the
        two.

        The default implementation does nothing and returns ``None``
        
        :param e: The  :class:`EagleFilePart` being visited.
        :rtype: Any

        """
        return None

    def default_post(self,e, context):
        """Default post-order visitor function.  The default implementation does nothing.
        
        :param e: The  :class:`EagleFilePart` being visited.
        :param context: The value returned by corresponding pre-order visitor.
        :rype: ``None``
        """
        pass

    def visit(self, efp):
        """ Run this visitor on the subtree rooted at ``efp``.
        
        :param efp: The :class:`EagleFilePart` at the root of the tree.
        :rtype:  ``self``
        """
        if self.visitFilter(efp):
            context = efp.accept_preorder_visitor(self)

        if self.decendFilter(efp):
            for e in efp.get_children():        
                self.visit(e)
                
        if self.visitFilter(efp):
            context = efp.accept_postorder_visitor(self, context)

        return self


#{% for tag in tags %}

#{%if not tag.customchild %}
#{% set classname = tag.classname %}
#{% else %}
#{% set classname = "Base_" + tag.classname %}
#{%endif%}

class {{classname}}({{tag.get_all_base_classes_as_str()}}):
    """
    Class representing the contents of a <{{tag.tag}}> tag in Eagle files.

    Attributes:

    #{%for a in tag.attrs %}
    * :code:`{{a.accessorName}}`

    #{%endfor%}

    #{%if tag.hasCollections %}

    Collections:

    #{%for a in tag.singletons %}
    * :code:`{{a.accessorName}}`: Singleton {{a.get_contained_type_list_doc_string("or")}} object. 

    #{%endfor%}

    #{%for a in tag.lists %}
    * :code:`{{a.accessorName}}`: List of {{a.get_contained_type_list_doc_string("and")}} objects.

    #{%endfor%}

    #{%for a in tag.maps %}
    * :code:`{{a.accessorName}}`: Map of {{a.get_contained_type_list_doc_string("and")}} objects indexed by their :code:`{{a.mapkey}}`.


    #{%endfor%}

    #{%endif%}
    """
    def __init__(self):
        """
        Construct an empty :class:`{{classname}}` object.
        """
        #{% for c in tag.get_all_base_classes_as_list() %}
        {{c}}.__init__(self)
        #{% endfor %}
        
        #{%for a in tag.attrs %}
        self.{{a.name}}=None
        #{%endfor%}
        #{%for l in tag.lists %}
        self.{{l.name}}=[]
        #{%endfor%}
        #{%for l in tag.attrLists %}
        self.{{l.name}}=[]
        #{%endfor%}
        #{%for m in tag.maps %}
        self.{{m.name}}={} #tecollections.OrderedDict()  For unclear reasons, this caused ordering to become more unpredictable, rather than less.
        #{%endfor%}
        #{%for s in tag.singletons %}
        self.{{s.name}}=None
        #{%endfor%}

        #{%if tag.preserveTextAs != "" %}
        self.{{tag.preserveTextAs}} = ""
        #{%endif%}

        
    @classmethod
    def _from_et(cls,root,parent):
        """
        Create a :class:`{{tag.classname}}` from a :code:`{{tag.tag}}` element.
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that should hold the resulting :class:`EagleFilePart`
        :rtype: :class:`{{tag.classname}}`
        """
        ## Call the constructor
        n = cls()
        n._init_from_et(root,parent)
        return n

    def _get_error_name(self):
        if hasattr(self, "get_name"):
            return self.get_name();
        else:
            return "{{tag.classname}}";
        
    def  _init_from_et(self, root, parent):
        """
        Initialized a :class:`{{tag.classname}}` from a :code:`{{tag.tag}}` element.  This is useful if you have a subclass of :class:`{{tag.classname}}` .
        
        :param root: The element tree tree to parse.
        :param parent: :class:`EagleFilePart` that will become the parent of :code:`this` .
        :rtype: :class:`{{tag.classname}}`
        """
        try:
            self.root = root
            
            if root.tag != "{{tag.tag}}":
                raise EagleFormatError("Tried to create {{tag.tag}} from " + root.tag)

            #{%for a in tag.attrs%}
            self.{{a.name}}={{a.parse}}(parent, "{{a.vtype}}", {{a.get_literal_default()}}, root.get("{{a.xmlName}}"))
            #{%endfor%}

            self.parent = parent

            ### populate the maps by searching for elements that match xpath and generating objects for them.

            #{%for m in tag.maps%}
            for c in root.xpath("{{m.xpath}}"):
                self.add_{{m.accessorName}}(self.get_class_for_tag(c.tag)._from_et(c, self))
            #{%endfor%}

            ### Do the same for the lists

            #{%for l in tag.lists %}
            for c in root.xpath("{{l.xpath}}"):
                self.add_{{l.accessorName}}(self.get_class_for_tag(c.tag)._from_et(c,self))
            #{%endfor%}

            ### Do the same for the attr lists

            #{%for l in tag.attrLists %}
            for c in root.get("{{l.attr}}").split(" "):
                self.add_{{l.accessorName}}(c)
            #{%endfor%}

            ### And the singletons

            #{%for s in tag.singletons %}
            x = root.xpath("{{s.xpath}}")
            if len(x) is not 0:
                self.set_{{s.accessorName}}(self.get_class_for_tag(x[0].tag)._from_et(x[0],self))
            #{%endfor%}

            ### And, finally, if the objects wants the text from the tag.

            #{%if tag.preserveTextAs != "" %}
            self.{{tag.preserveTextAs}} = root.text or "" # If root.text is None, we still need a string.
            #{% endif %}
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e


    def sortkey(self):
        #{% if tag.dontsort %}
        return ""
        #{%elif tag.sortattr != None %}
        return self.{{tag.sortattr}};
        #{%else%}
        r = ""
        #{% for a in tag.attrs %}
        r = r + str(self.{{a.name}})
        #{% endfor %}
        return r
        #{% endif %}

    def get_et(self):
        """
        Generate a <{{tag.tag}}> element tree for a :class:`{{tag.classname}}`.
        
        :rtype:  :class:`ElementTree`.
        
        """
        try:
            r = ET.Element("{{tag.tag}}")

            ### Set the tag attributes 

            #{%for a in tag.attrs%}

            ## Unparse the values.

            v = {{a.unparse}}(self, "{{a.vtype}}", {{a.get_literal_default()}},  self.{{a.name}})

            ## For required attributes None becomes "".  For optional attributes, we just leave the attribute out.
            if not (isinstance(self.get_parent(), LibraryFile) and {{"supress_in_lib_file" in a.quirks}}):  # special case for the name of library.
                if v is not None:
                    r.set("{{a.xmlName}}", v)
            #{%if a.required %}
                else:
                    r.set("{{a.xmlName}}", "")
            #{%endif%}

            #{%endfor%}

            ### process the sections in order.  They have to be in section order,
            ### because eagle files are order dependent.

            #{%for l in tag.sections%}

            ## For some tags, Eagle generates empty tags when there's no contant
            ## rather than just leaving the tag out.  We mark these with
            ## Tag.requireTag in GenerateSwoop.py and force their generation
            ## here.

            #{%if l.requireTag %}
            smartAddSubTags(r, "{{l.xpath}}")
            #{%endif%}

            #{%if l.type == "List" %}

            ## add a list.

            if len(self.{{l.name}}) is not 0:
                target = smartAddSubTags(r, "{{l.xpath}}")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(self.{{l.name}},key=lambda x: x.sortkey())])

            #{%elif l.type == "Map" %}

            ## add a map.

            if len(self.{{l.name}}) is not 0:
                target = smartAddSubTags(r, "{{l.xpath}}")
                # add them in sorted order.  This gives us a simple canonicalization that makes it feasible to use diff to compare files.
                target.extend([i.get_et() for i in sorted(list(self.{{l.name}}.values()),key=lambda x: x.sortkey())])

            #{%elif l.type == "AttrList" %}

            if self.{{l.name}} is not None:
                r.set("{{l.attr}}", " ".join(self.{{l.name}}))

            #{%else%}

            ## or add a singleton.

            if self.{{l.name}} is not None:
                target = smartAddSubTags(r, "{{l.xpath}}")
                target.append(self.{{l.name}}.get_et())
            #{%endif%}
            #{%endfor%}

            ## set the text, if its needed.

            #{%if tag.preserveTextAs != "" %}
            r.text = self.{{tag.preserveTextAs}}
            #{% endif %}
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return r

    def clone(self):
        """
        Recursively clone this :code:`{{tag.classname}}`.  It will be identical to the original, but it's parent will be :code:`None`.
        
        :rtype: :class:`{{tag.classname}}`
        """
        try:
            n = copy.copy(self)
            #{%for m in tag.maps%}
            n.{{m.name}} = {}
            for x in list(self.{{m.name}}.values()):
                n.add_{{m.accessorName}}(x.clone())
            #{%endfor%}
            #{%for l in tag.lists %}
            n.{{l.name}} = []
            for x in self.{{l.name}}:
                n.add_{{l.accessorName}}(x.clone())
            #{%endfor%}
            #{%for l in tag.attrLists %}
            n.{{l.name}} = []
            for x in self.{{l.name}}:
                n.add_{{l.accessorName}}(x)
            #{%endfor%}
            #{%for s in tag.singletons %}
            n.{{s.name}} = None
            if self.{{s.name}} is not None:
                n.set_{{s.accessorName}}(self.{{s.name}}.clone())
            else:
                n.set_{{s.accessorName}}(None)
            #{%endfor%}
            n.parent = None
        except SwoopError as e:
            e.text = "{}:{}".format(self._get_error_name(), e.text)
            raise e
        return n

    def accept_preorder_visitor(self, visitor):
        try:
            pre = getattr(visitor, "{{tag.classname}}_pre")
            return pre(self)
        except AttributeError:
            return visitor.default_pre(self)
        
    def accept_postorder_visitor(self, visitor, context):
        try:
            post = getattr(visitor, "{{tag.classname}}_post")
            post(self,context)
        except AttributeError:
            visitor.default_post(self,context)

    def is_equal(self, other):
        """
        Check whether two :code:`EagleFilePart` objects are identical.
        
        :param other: Object to compare to.
        :returns: :code:`True` if they are identical, otherwise, :code:`False`
        """
        return self.get_xml() == other.get_xml()
        
    ### Getters/Setters for attribute values

    #{%for a in tag.attrs%}
    def get_{{a.accessorName}}(self):
        """ Return the value of :code:`{{a.name}}` for this :class:`{{tag.classname}}`.  This corresponds to the :code:`{{a.name}}` attribute of a :code:`<{{tag.tag}}>` in an Eagle file.
        
        :rtype: :code:`{{a.vtype}}`
        """
        return self.{{a.name}}

    def set_{{a.accessorName}}(self,v):
        """ Set the value of :code:`{{a.name}}` for this  :class:`{{tag.classname}}`.  This corresponds to the :code:`{{a.name}}` attribute of a :code:`<{{tag.tag}}>` in an Eagle file.

        :param v: new value
        :rtype: :code:`self`
        """
                        
        #{%if a.isKey %}
        oldkey = self.{{a.name}}
        #{% endif %}
        if not typeCheck("{{a.vtype}}", v, {{a.required}}):
            raise SwoopError("Illegal value ({}) of type {} for attribute '{{a.name}}' of {{tag.classname}} object (should be {{a.vtype}}).".format(v, type(v)))
        self.{{a.name}} = v
        
        #{%if a.isKey %}
        if self.get_parent() is not None:
            self.get_parent()._rekey_child(oldkey, self);
        #{% endif %}
        return self

    def with_{{a.accessorName}}(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`{{a.name}}`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`{{a.name}}` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_{{a.accessorName}}()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float, bool]:
            return self if self.{{a.name}} == v else None
        elif callable(v):
            return self if v(self.{{a.name}}) else None
        else:
            raise SwoopError("Illegal type passed to with_{{a.accessorName}}")

    def without_{{a.accessorName}}(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`{{a.name}}`. 
        
        Return :code:`self` if one of the following is :code:`True`:

        1.  :code:`{{a.name}}` is not equal to :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_{{a.accessorName}}()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """
        
        if type(v) in [str, int, float, bool]:
            return self if self.{{a.name}} != v else None
        elif callable(v):
            return self if not v(self.{{a.name}}) else None
        else:
            raise SwoopError("Illegal type passed to without_{{a.accessorName}}")


    #{%endfor%}

    ##### Lookup functions that return EFPs instead of just attribute values.
    
    #{%for a in tag.attrs%}
    #{%if a.lookupEFP != None %}
    def find_{{a.accessorName}}(self):
        """Find the :class:`{{a.lookupEFP[0]}}` object refered to by the :code:`{{a.name}}` attribute of this object.  This is like
        :meth:`get_{{a.name}}`, except it returns the :class:`{{a.lookupEFP[0]}}` object instead of its name.
        
        :returns: The object
        :rtype: :class:`{{a.lookupEFP[0]}}`

        """
        f = {{a.lookupEFP[1]}}
        return f(self, self.{{a.name}})
    #{%endif%}
    #{%endfor%}
    
    #{%if tag.preserveTextAs != "" %}
    def with_{{tag.preserveTextAs}}(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`{{tag.preserveTextAs}}`.  For use in combination with :class:`From` objects.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`{{tag.preserveTextAs}}` equals :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_{{tag.preserveTextAs}}()` is :code:`True`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.{{tag.preserveTextAs}} == v else None
        elif callable(v):
            return self if v(self.{{tag.preserveTextAs}}) else None
        else:
            raise SwoopError("Illegal type passed to with_{{tag.preserveTextAs}}")

    def without_{{tag.preserveTextAs}}(self,v):
        """
        Filter this :code:`EagleFilePart` object based on the value of :code:`{{tag.preserveTextAs}}`.
        
        Return :code:`self` if one of the following is true:

        1.  :code:`{{tag.preserveTextAs}}` does not equal :code:`v`
        2.  :code:`v` is callable and :code:`v(self.get_{{tag.preserveTextAs}}()` is :code:`False`

        This is useful in combination with :class:`From` object.
        
        :param t: The value to check for or a callable object.
        :returns: :code:`self` if the criteria above are met and :code:`None` otherwise. 
        :rtype: :class:`EagelFilePart` or :code:`None`

        """

        if type(v) in [str, int, float]:
            return self if self.{{tag.preserveTextAs}} == v else None
        elif callable(v):
            return self if v(self.{{tag.preserveTextAs}}) else None
        else:
            raise SwoopError("Illegal type passed to without_{{tag.preserveTextAs}}")
    #{% endif %}


    
    ### Adder/getter/lookup for lists
    
    #{%for l in tag.lists%}
    #{%if not l.suppressAccessors %}
    def add_{{l.accessorName}}(self, s):
        """ Add a {{l.get_contained_type_list_doc_string()}} to the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.

        :param s: The {{l.get_contained_type_list_doc_string("or")}} to add.
        :rtype: :code:`self`
        """
        if not any([
                #{% for t in l.get_contained_type_list() %}
                isinstance(s, {{t}}),
                #{% endfor %}
            ]):
            raise SwoopError("Argument to {{classname}}.add_{{l.accessorName}}() should be of type {{l.get_contained_type_list_string()}}.  Got " + str(type(s).__name__) + ".")
        
        self.{{l.name}}.append(s)
        if s.parent is not None and s.parent is not self:
            s.parent.remove_{{l.accessorName}}(s)

        s.parent = self
        return self

    def get_nth_{{l.accessorName}}(self, n):
        """ get then nth {{l.get_contained_type_list_doc_string("or")}} object from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :param n: Index of the item to return.

        :rtype: {{l.get_contained_type_list_doc_string()}} object
        """
        return self.{{l.name}}[n]

    def get_{{l.name}}(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`{{l.name}}` list of {{l.get_contained_type_list_doc_string("or")}} objects for this :class:`{{tag.classname}}`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of {{l.get_contained_type_list_doc_string("and")}} objects
        :rtype: List of {{l.get_contained_type_list_doc_string("and")}} objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.{{l.name}}

    def clear_{{l.name}}(self):
        """
        Remove all the {{l.get_contained_type_list_doc_string("and")}} objects from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :rtype: :code:`self`
        """
        for efp in self.{{l.name}}:
            efp.parent = None
        self.{{l.name}} = []
        return self

    def remove_{{l.accessorName}}(self, efp):
        """
        Remove a {{l.get_contained_type_list_doc_string()}} from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :param efp: The {{l.get_contained_type_list_doc_string("or")}} object to remove.

        :rtype: :code:`self`
        """
        self.{{l.name}} = [x for x in self.{{l.name}} if x != efp]

        if efp.parent is self:
            efp.parent = None
        return self

    #{%else%}
    # {{l.name}} accessor supressed
    #{%endif%}
    #{%endfor%}

    #{%for l in tag.attrLists%}
    #{%if not l.suppressAccessors %}
    def add_{{l.accessorName}}(self, s):
        """ Add a {{l.get_contained_type_list_doc_string()}} to the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.

        :param s: The {{l.get_contained_type_list_doc_string("or")}} to add.
        :rtype: :code:`self`
        """
        if not isinstance(s, str):
            raise SwoopError("Argument to {{classname}}.add_{{l.accessorName}}() should be str.  Got " + str(type(s).__name__) + ".")
        
        self.{{l.name}}.append(s)
        return self

    def get_nth_{{l.accessorName}}(self, n):
        """ get then nth {{l.get_contained_type_list_doc_string("or")}} object from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :param n: Index of the item to return.

        :rtype: {{l.get_contained_type_list_doc_string()}} object
        """
        return self.{{l.name}}[n]

    def get_{{l.name}}(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`{{l.name}}` list of {{l.get_contained_type_list_doc_string("or")}} objects for this :class:`{{tag.classname}}`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of {{l.get_contained_type_list_doc_string("and")}} objects
        :rtype: List of {{l.get_contained_type_list_doc_string("and")}} objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented.")
        return self.{{l.name}}

    def clear_{{l.name}}(self):
        """
        Remove all the {{l.get_contained_type_list_doc_string("and")}} objects from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :rtype: :code:`self`
        """
        self.{{l.name}} = []
        return self

    def remove_{{l.accessorName}}(self, v):
        """
        Remove a {{l.get_contained_type_list_doc_string()}} from the :code:`{{l.name}}` of this :class:`{{tag.classname}}`.
        
        :param efp: The {{l.get_contained_type_list_doc_string("or")}} object to remove.

        :rtype: :code:`self`
        """
        self.{{l.name}} = [x for x in self.{{l.name}} if x != v]
        return self

    #{%else%}
    # {{l.name}} accessor supressed
    #{%endif%}
    #{%endfor%}

    ### Add, lookup, and get for maps
    #{%for m in tag.maps%}
    #{%if not m.suppressAccessors %}
    def add_{{m.accessorName}}(self, s):
        """ Add a {{m.get_contained_type_list_doc_string()}} to the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.

        :param s: The {{m.get_contained_type_list_doc_string()}} to add.
        :rtype: :code:`self`
        """
        if not any([
                #{% for t in m.get_contained_type_list() %}
                isinstance(s, {{t}}),
                #{% endfor %}
            ]):
            raise SwoopError("Argument to {{classname}}.add_{{m.accessorName}}() should be of type {{m.get_contained_type_list_string()}}.  Got " + str(type(s).__name__) + ".")
        

        self.{{m.name}}[s.get_{{m.mapkey}}()] = s

        s.parent = self
        return self

    def get_nth_{{m.accessorName}}(self, n):
        """ get then nth {{m.get_contained_type_list_doc_string("or")}} object from the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.
        
        :param n: Index of the item to return.

        :rtype: {{m.get_contained_type_list_doc_string()}} object
        """
        return list(self.{{m.name}}.values())[n]

    def get_{{m.accessorName}}(self, key):
        """ Lookup and return a {{m.get_contained_type_list_doc_string("or")}} from the :code:`{{m.name}}` of  this :class:`{{tag.classname}}`.
        
        :param key: A :code:`str` to use for the lookup.  The lookup uses the :code:`{{m.mapkey}}` of the {{m.get_contained_type_list_doc_string("or")}} objects.

        :rtype: A {{m.get_contained_type_list_doc_string()}} object or :code:`None`, if there is no such item.
        """
        return self.{{m.name}}.get(key)


    def get_{{m.name}}(self, attrs=None, type=None):
        """Return (and possibly filter) items in the the :code:`{{m.name}}` map of {{m.get_contained_type_list_doc_string("or")}} objects for this :class:`{{tag.classname}}`.
        
        This functions provides a mechanism for filtering the items as well.
        The keys in :code:`attrs` are taken as attributes names and the
        values are requested values.  Items in the list that have all the
        requested values for the corresponding attributes will be returned.  

        A if :code:`type` is not :code:`None`, the item will match if it is an
        instance of the type provided.
        
        :param attrs: A set of key-value pairs that represent a filter to apply to the item's attributes.
        :param type:  A type to filter on.  Only items that are an instance of this type will be returned.
        :returns: A List of {{m.get_contained_type_list_doc_string("and")}} objects
        :rtype: List of {{m.get_contained_type_list_doc_string("and")}} objects
        """
        if attrs is not None or type is not None:
            raise NotImplementedError("filtered get not implemented")
        return list(self.{{m.name}}.values())
        

    def clear_{{m.name}}(self):
        """
        Remove all the {{m.get_contained_type_list_doc_string("and")}} objects from the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.
        
        :rtype: :code:`self`
        """
        for efp in list(self.{{m.name}}.values()):
            efp.parent = None
        self.{{m.name}} = {}
        return self

    def remove_{{m.accessorName}}(self, efp):
        """
        Remove a {{m.get_contained_type_list_doc_string()}} from the :code:`{{m.name}}` of this :class:`{{tag.classname}}`.
        
        :param efp: The {{m.get_contained_type_list_doc_string("or")}} object to remove.

        :rtype: :code:`self`
        """
        if self.{{m.name}}[efp.get_{{m.mapkey}}()] == efp:
            del self.{{m.name}}[efp.get_{{m.mapkey}}()]
            efp.parent = None
            return self
        else:
            raise SwoopError("Tried to use remove_{{m.accessorName}}() to delete the wrong kind of child?: {}".format(str(efp)))
    
    #{%endif%}
    #{%endfor%}


    
    ### Getter/Setter for singletons.

    #{%for l in tag.singletons%}
    #{%if not l.suppressAccessors %}
    def set_{{l.accessorName}}(self, s):
        """ Set the {{l.get_contained_type_list_doc_string()}} for this  :class:`{{tag.classname}}`.

        :param s: {{l.get_contained_type_list_doc_string()}} to set.
        :rtype: :code:`self`
        """
        if self.{{l.name}} is not None:
            self.{{l.name}}.parent = None
        self.{{l.name}} = s
        if s is not None:
            s.parent = self
        return self

    def get_{{l.accessorName}}(self):
        """ Get the {{l.accessorName}} from this :class:`{{tag.classname}}`.
        
        :rtype: {{l.get_contained_type_list_doc_string()}} object
        """
        return self.{{l.name}}

    #{%endif%}
    #{%endfor%}

    #{%if tag.preserveTextAs != "" %}
    def set_{{tag.preserveTextAs}}(self, s):
        """ Set the text content for this :class:`{{tag.classname}}`.

        :param s: text to set.
        :rtype: :code:`self`
        """
        self.{{tag.preserveTextAs}} = s
        return self

    def get_{{tag.preserveTextAs}}(self):
        """ Get the text content from this :class:`{{tag.classname}}`.
        
        :rtype: the text content.
        """
        return self.{{tag.preserveTextAs}}
    
    #{% endif %}
    
    def get_children(self):
        """
        Get all the children of this :class:`EagleFilePart`.
        
        :rtype: List of :class:`EagleFilePart` objects
        """
        r = []

        #{%for l in tag.lists%}
        r = r + self.{{l.name}}
        #{%endfor%}

        #{%for m in tag.maps%}
        r = r + list(self.{{m.name}}.values())
        #{%endfor%}

        #{%for s in tag.singletons%}
        if self.{{s.name}} is not None:
            r = r + [self.{{s.name}}]
        #{%endfor%}

        return r

    def remove_child(self, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        #{%for m in tag.maps%}
        try:
            self.remove_{{m.accessorName}}(efp)
        except:
            pass
        #{%endfor%}
        #{%for l in tag.lists%}
        try:
            self.remove_{{l.accessorName}}(efp)
        except:
            pass
        #{%endfor%}
        #{%for s in tag.singletons%}
        if self.get_{{s.accessorName}}() == efp:
            self.set_{{s.accessorName}}(None)
        #{%endfor%}

    def _rekey_child(self, oldkey, efp):
        """
        Remove a child :class:`EagleFilePart` object.
        
        :param efp: the class:`EagleFilePart` object to remove.
        :return: Nothing
        """
        #{%for m in tag.maps%}
        try:
            if self.get_{{m.accessorName}}(oldkey) == efp:
                del self.{{m.name}}[oldkey]
                self.add_{{m.accessorName}}(efp)
        except SwoopError:
            pass
        #{%endfor%}

    #{%if tag.has_maps() %}
    def check_sanity(self, visited_efps = None):
        {{tag.baseclass}}.check_sanity(self, visited_efps)

        # Check whether keys in our maps match the keys in our children
        #{% for m in tag.maps %}
        for k in self.{{m.name}}:
            if self.{{m.name}}[k].get_{{m.mapkey}}() != k:
                raise SwoopError("Child's {{m.mapkey}} ('{}') doesn't match key in parent's map ('{}')".format(self.{{m.name}}[k].get_{{m.mapkey}}(),k))
        #{% endfor %}
    #{%endif%}

    def __str__(self):
        r = "["+repr(self)+" "
        #{%for a in tag.attrs %}
        r = r + "{{a.name}}:" + str(self.get_{{a.accessorName}}()) + " "
        #{%endfor%}
        r = r + "]"
        return r
            
    def dump(self, indent="", increment="   "):
        """
        Recursive debug dump.
        
        :param indent:  Indentation string.  The output will be indented by this much.
        :param increment: This will be appendeded to :code:`indent` on recursive invocations.

        :rtype: :code:`None`
        """
        print(indent + str(self.__class__.__name__), end=' ')
        try:
            print(self.get_name())
        except:
            print()
            pass
        for c in self.get_children():
            c.dump(indent + "   ")

        
EagleFile.class_map["{{tag.tag}}"] = {{classname}}
         
#{% endfor %}

class Instance (Base_Instance):
    """ 
    Extra functions for Intsances.
    """
    def __init__(self):
        Base_Instance.__init__(self)

    def find_part(self):
        """
        Get the :class:`Part` object this :class:`Instance` belongs to.
        """
        return self.get_root().parts[self.part]

EagleFile.class_map["instance"] = Instance

class Part (Base_Part):
    """Extra functions for Parts.  Sanity checks, and facilities for find the
    symbols, devices, etc. for a part.

    """
    def __init__(self):
        Base_Part.__init__(self)


    def check_sanity(self, visited_efps = None):
        #assert self.get_device() is not None

        try:
            assert self.find_library() is not None
        except Exception as e:
            raise SwoopError("Library '" + self.library +  "' missing for '" + str(self.name) + "'")
        
        try:
            assert self.find_deviceset() is not None
        except Exception as e:
            raise SwoopError("DeviceSet '" + self.find_library().name + ":" + self.deviceset + "' missing for '" + str(self.name) + "'")

        try:
            assert self.find_device() is not None
        except Exception as e:
            raise SwoopError("Device '" + self.find_library().name + ":" + self.find_deviceset().name + ":" + self.device + "' missing for '" + str(self.name) + "'")
        
        Base_Part.check_sanity(self, visited_efps)
        
         
    def find_library(self):
        """
        Get the library that contains this part
        """
        lib = self.get_root().libraries.get(self.library)
        return lib

    def find_deviceset(self):
        """
        Get the deviceset for this part.
        """
        lib = self.find_library();
        if lib is None:
            return None;
        deviceset = lib.devicesets.get(self.deviceset)
        return deviceset
        
    def find_device(self):
        """
        Get the library entry for this part
        """
        deviceset = self.find_deviceset()
        if deviceset is None:
            return None;
        assert self.device is not None
        device = deviceset.devices.get(self.device)
        return device

    def find_technology(self):
        """
        Get the library entry for this part
        """
        device = self.find_device()
        if device is None:
            return None;
        tech = device.technologies.get(self.technology)
        return tech

        
    def find_package(self):
        """
        Get the library entry for this part
        """
        device = self.find_device();
        lib = self.find_library();
        if device.package is not None:
            package = lib.packages.get(device.package);
        else:
            package = None
        return package
    

    def get_all_attributes(self):
        """Return a map of attribute names to values.  These include attributes
        defined in the library as well as those defined for this part.
        Modifying the map has no effect on the :code:`Part`.

        """
        r = {x.get_name(): x.get_value() for x in self.find_technology().get_attributes()}
        r.update({x.get_name(): x.get_value() for x in self.get_attributes()})
        return r
        
    def set_attribute(self,name, value):
        """Set an attribute on a part, creating it if necessary.

        If the attribute exists in the library, and is marked as constant, then raise a :code:`SwoopError`.
        """

        tech_attribute = self.find_technology().get_attribute(name)

        if tech_attribute is None or (tech_attribute is not None and not tech_attribute.get_constant()):
            if name in self.attributes:
                self.attributes[name].set_value(value)
            else:
                self.add_attribute(Attribute().
                                   set_name(name).
                                   set_value(value))
        else:
            raise SwoopError("Setting attribute value on part {}, but attribute '{}' is marked constant in library ({}:{}:{}:{}).".format(tech_attribute, tech_attribute.get_constant(), self.get_name(), name, self.get_library(), self.get_deviceset(), self.get_device(), self.get_technology()))

        return self


EagleFile.class_map["part"] = Part


class Attribute (Base_Attribute):

    """Extra functionality for Attributes.  Attributes are used in many places in
    eagle files and they require different attributes in some cases.

    """
    def __init__(self):
        Base_Attribute.__init__(self)

    def __str__(self):
        return self.name + " = '" + str(self.value) + "' [const=" + str(self.constant) + "]";

    def get_in_library(self):
        if isinstance(self.get_parent(), Technology):
            return True;
        elif isinstance(self.get_parent(), Part):
            return False
        elif isinstance(self.get_parent(), Instance):
            return False
        elif isinstance(self.get_parent(), Element):
            return False
        elif isinstance(self.get_parent(), EagleFile):
            return False
        elif isinstance(self.get_parent(), Moduleinst):
            return False
        else:
            raise SwoopError("Unexpectedly found attribute with parent of type '{}'".format(type(self.get_parent())))

    @classmethod
    def _from_et (cls, attribute_root, parent):
        n = Attribute()
        n. _init_from_et(attribute_root, parent)
        
        return n

    def get_et (self):
        n = Base_Attribute.get_et(self)
        
        if not self.get_in_library():
            if "constant" in n.attrib:
                del n.attrib["constant"]

        return n

EagleFile.class_map["attribute"] = Attribute

#### Extra methods for DeviceSets

def convertToExternal(self):
    """
    This converts the :class:`Deviceset` into an external deviceset.  This means that it
    has no associated package.  It can, however, have attributes, and those
    are stored in the "" device.  You can't just delete all the packages,
    since you'd lose the attributes.  This copies them from the first
    package.
    """
    if len(self.get_devices()) > 0:
        d = self.get_devices()[0]
        self.clear_devices()
        d.set_name("").set_package(None).clear_connects()
    else:
        d = (Device().
             set_name("").
             set_package(None).
             add_technology(Technology().
                            set_name("")))
    self.add_device(d)

    From(d).get_technologies().add_attribute(Attribute().set_name("_EXTERNAL_"))

setattr(Deviceset, "convertToExternal", convertToExternal)
        
class LibraryFile(Base_LibraryFile):
    def __init__(self):
        Base_LibraryFile.__init__(self)
        
    @classmethod
    def _from_et (cls,et, parent, filename):
        """
        Loads a Library file from an ElementTree.Element representation.
        """
        r = cls()
        r._init_from_et(et, parent)
        if r.get_library().name is None: 
            r.get_library().set_name(os.path.basename(filename)[:-4])
        return r

    # def get_library_copy(self):
    #     return copy.deepcopy(self.library)

    
#print EagleFile.class_map
class LibraryCache(object):
    """
    A library file cache.  Save the time of opening libraries repeatedly.  
    
    An instance of this is available as :code:`Swoop.library_cache`, but you may build your own, if you want.
    """
    
    def __init__(self):
        self.libfile_to_lib = {}
        self.libname_to_path = {}

    def register_library(self, path):
        """
        
        Register a library file with the cache.  This allows you to later
        request the library by name.  For instance if you register
        :code:`foo.lbr` you can ask for :code:`foo'. 

        :param path: The path to the lbr file.  The path is canonicalized internally (and made absolute) so if :code:`bar/foo.lbr` is the same as :code:`bar/../bar/foo.lbr`.

        """
        cpath = os.path.realpath(path)
        libname = os.path.split(cpath)[1].replace(".lbr","").upper()
        log.debug("Registered library {} as {}".format(path, libname))
        self.libname_to_path[libname] = cpath

    def load_library_by_path(self, path):
        """ 
        Load a library using a path to file.

        :param path: The path to the lbr file.  The path is canonicalized internally (and made absolute) so if :code:`bar/foo.lbr` is the same as :code:`bar/../bar/foo.lbr`.
        """
        
        cpath = os.path.realpath(path)
        self.register_library(path) # make sure we can find it later via load_library_by_name
        if cpath not in self.libfile_to_lib:
            log.debug("LibraryCache miss: {}".format(path))
            self.libfile_to_lib[cpath] = LibraryFile.open(cpath)
        else:
            log.debug("LibraryCache hit: {}".format(path))
        return self.libfile_to_lib[cpath]

    def load_library_by_name(self, name):
        """
        Load a library by (case insensitive) name.  If you haven't registered the path to the library or accessed it previously via :code:`load_library_by_path`, it will raise an exception.

        :param name: Library name (case insensitive)
        """

        if name.upper() in self.libname_to_path:
            r = self.load_library_by_path(self.libname_to_path[name.upper()])
            log.debug("Returning {} for libname '{}'".format(r, name))
            return r
        else:
            raise SwoopError("Unknwon library name {} (did you register the file?)")
    
library_cache = LibraryCache()
